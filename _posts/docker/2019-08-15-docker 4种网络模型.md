---
layout:     post
title:      "2019-04-23-理解docker镜像原理"
subtitle:   "docker学习记录"
date:       2019-08-15
author:     "CHuiL"
header-img: "img/k8s-bg.png"
tags:
    - docker
---

## host模式
与宿主机共享同一个网络命名命名空间，容器的IP地址即为宿主机的ip地址，容器可以和宿主机一样，使用宿主机的网卡和外界通信，端口自然也可以舒勇宿主机的端口，无需额外进行NAT转换。  
不在需要经过bridge的转发或者数据包的拆封，性能上有很大优势。  
容器不在拥有隔离，独立的网络栈。容器会与宿主机竞争网络战的使用，并且容器的崩溃可能导致宿主机的崩溃。  
容器内部将不在拥有所有的端口资源，所以一些常见的服务端口可能已经被宿主机占用。

![image](/chuil/img/docker/08-15-1.png) 

## bridge模式
默认的模式，也是最常见的模式。在这种模式下，docker会在宿主机上创建一个docker0的网桥，并且为每个新建的容器建立自己的网络命名空间，并且使用Veth设备对连接到docker0上，容器内的veth则命名为eth0。由于连接在docker0这个网桥上，自然与docker0属于同一网段，通信也是经由docker0网桥进行转发，但是与宿主机ip地址不在同个网段。  
由于容器都是绑定在这个docker0网桥上的，并且属于同一个网段，自然容器之间可以相互访问。也可以通过docker0访问外部的网络。那么外部网络如何访问到docker内部的进程呢？这里还需要iptables NAT来进行转发，如果我们为容器绑定了一个宿主机上的端口映射，那么在iptables中将有一条记录表示将流经该端口的请求转发到目标容器上的ip地址上。


![image](/chuil/img/docker/08-15-2.png)

## none模式
这种模式下，容器有独立的网络栈，但不包含任何网络配置，只具有lo这个loopback网卡用于进程通信。可以通过第三方工具或手工方式来开发任意定制容器的网络，提供了最高的灵活性

## container模式
这种模式下，关联的容器之间处在同一个网络空间和网络栈，换句话说，可以在一个容器中直接使用localhos+端口访问另一个容器上的服务进程。不过他们与宿主机仍然是隔离的。如下图  
![image](/chuil/img/docker/08-15-3.png)


## 参考
[Docker网络模型对比](https://www.jianshu.com/p/421c9181456e)