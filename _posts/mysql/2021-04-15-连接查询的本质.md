---
layout:     post
title:      "连接查询的本质"
subtitle:   ""
date:       2021-04-15
author:     "CHuiL"
header-img: "/img/mysql-bg.png"
tags:
    - mysql
---

连接的本质就是笛卡尔积，不过是根据条件筛选出来的笛卡尔积；

### 内外连接的差别
就像我们在计算笛卡尔积那样，我们总是要先选择一个集合，然后在从这个集合选取出一条记录来与另一个集合中的记录匹配一样，我们同样需要先选择一个表，来作为我们的**驱动表**，另外一个表就是**被驱动表**；  
我们先根据针对驱动表的where查询条件，先筛选一遍驱动表的集合，然后在从这个集合中，取一条记录，与被驱动表的记录进行匹配，被驱动表的记录需要满足where中的查询条件，如 t1.id = t2.id (在t1记录确定的情况下，t1.id就是该条记录具体的值)；  
将记录匹配返回到结果集，依次将所有记录匹配完成。  
![image](/chuil/img/mysql/unite-1.png)
但是，当我们取驱动表中的记录，然后根据`连接条件`去被驱动表中筛选符合条件的记录时，被驱动表中可能不存在符合条件的记录，此时驱动表的这条记录是否依旧返回给结果集，这就是内外连接最本质的差别，内连接结果集不包含这条记录，而外连接则包含，驱动表中没有的记录，字段用null填充；    
而左外连接的区别，就是取那一边作为驱动表；  

### on条件和where条件
不符合where条件的记录都会被筛选掉；而on语句则不同；  
当on语句作用与左连接时，on的条件只对`右`表有效，生成临时表，在根据where条件对临时表进行筛选，右连接时则只对`左`表有效；这是为了在类似t1.id = t2.id的条件时，能够保留驱动表中的数据而设计的；如果将t1.id = t2.id放在外连接的whete子句中，那么驱动表中没有对应被驱动表记录的记录，就不会返回了(需要验证); 可以理解为，在左连接时，约束右表的数据，有满足条件t1.id=t2.id时才能返回，不满足的不返回；而对左表不作用，即左边的数据不需要满足t1.id=t2.id，所以才能出现左边有数据，右边为null； 
所以在内连接的场景下，由于上述情况一定不反回，所以就和where没有区别了；


### 内连接 外连接语法
内连接：
- select * from t1,t2;  
- select * from t1 join t2;
- select * from t1 inner josin t2;
- select * from t1 cross join t2;

外连接：

- select * from t1 left join t2 on .. where..;